/*
Лабораторная работа 6. Вариант 3.
Вам необходимо реализовать механизм проверяемого ввода данных с потока ввода. При этом:

    Существует интерфейсный класс ввода, который будет иметь только 1 метод: Считывание с потока ввода >>
    Существует интерфейсный класс валидатора, который будет иметь только 1 метод:
    Проверка считанного значения(принимает в себя значение)
    Существует несколько классов считывания значений для типов: int, double, bool, string, char, array[N, type] 
    (для считывания массива должны использоваться другие считыватели). Нужно реализовать не менее трех считывателей 
    для разных типов. При этом у каждого ввода должен быть строго определен свой формат, 
    если формат не соблюден считывание должен повторятся до тех пор, пока пользователь не прервет его вводом 
    какого-либо спец символа(выбираем на свое усмотрение, можно например CTRL+D признак конца ввода).
    Существует несколько классов валидаторов например проверка больше меньше какого либо значения, 
    проверка на формат строки, проверка на соответствие определенному символу.
    Весь процесс считывания тогда будет выглядеть следующим образом, из потока ввода считываем данные 
    в класс считыватель который проверяет их на соответствие типу, если не возникает ошибки ввода, 
    тогда вызывается проверка на соответствие дополнительным правилам, которые заранее подаются 
    в считыватель при помощи конструктора.
    Считыватель может принимать в качестве аргумента конструктора параметр определяющий реакцию 
    на ошибку ввода, который будет при своем наличии требовать немедленного завершения программы 
    в случае ошибки. Требуется:
    1) Реализовать интерфейсные класс считывателя, а также несколько конечных реализаций
        (Считывание строки, целого числа, плавающей запятой, символа).
    2) (На половину баллов) Продемонстрировать работу считывателей данных, 
        считав некоторый набор информации из консоли.
    3) (Усложненный вариант) Реализовать интерфейсный класс валидатора, а также несколько 
        конечных реализаций(Проверка на максимальную длину строки, 
        максимальное/минимально значение числа, символа из предустановленного набора)
    4) (Усложненный вариант) Реализовать конвейер считывания информации, в котором будет 
        производиться последовательное считывание из потока ввод нескольких данных 
        разного формата с разным набором дополнительных проверок.
    5) (Усложненный вариант) Провести тестовое считывание данных из файлов 
        (с ошибкой (аварийное завершение программы) и без ошибок) и из стандартного
         потока ввода с ошибками при повторяющемся ввода.
*/
#include <iostream>
#include <string>
#include <limits>
#include <vector>
#include <stdexcept>
using namespace std;

/*
 * Интерфейсный класс для считывания данных.
 */
class InputReader {
public:
    /*
     * Считывание с потока ввода >>
     *
     * @param is Поток ввода.
     * @return Возвращает true, если чтение прошло успешно, иначе false.
     */
    virtual bool read(istream& is) = 0;
    virtual ~InputReader() = default;   // Деструктор для интерфейсного класса. Здесь можно освободить ресурсы
    // Важно для предотвращения утечек памяти
};

/*
 * Интерфейсный класс валидатора с одним методом: 
 * проверкой считанной считанного значения (принимает в себя значение)
 */
class Validator {
public:
    /*
     * Проверяет считанное значение на соответствие правилам.
     *
     * @param value Проверяемое значение.
     * @return Возвращает true, если значение валидно, иначе false.
     */
    virtual bool validate(const string& value) = 0;
    virtual ~Validator() = default;
};

/*
 * Считыватель для целых чисел.
 */
class IntReader : public InputReader {
private:
    int value;  // Значение, считанное из ввода.

public:
    /*
     * Читает целое число из потока.
     *
     * @param is Поток ввода.
     * @return Возвращает true, если чтение прошло успешно, иначе false.
     */
    bool read(istream& is) override {
        string input;
        while (true) {
            cout << "Введите целое число (или Ctrl+D для выхода): ";
            if (!getline(is, input) || input.empty()) return false;    // Проверка данных из потока

            try {
                value = stoi(input);                                   // Попытка преобразования в целое число
                return true;
            } catch (...) {                                                 // Перехват всех исключений
                cerr << "Неверный формат. Попробуйте снова." << endl; // Вывод сообщения об ошибке. Не буферизуется -> выводятся немедленно.
            }
        }
    }

    /*
     * Перегрузка оператора вывода для IntReader.
     *
     * @param os Поток вывода.
     * @param reader Объект IntReader.
     * @return Возвращает поток вывода.
     */
    friend ostream& operator<<(ostream& os, const IntReader& reader) {
        os << "IntReader {value: " << reader.value << "}";
        return os;
    }
};

/*
 * Считыватель для чисел с плавающей точкой.
 */
class DoubleReader : public InputReader {
private:
    double value;  // Значение, считанное из ввода.

public:
    /*
     * Читает число с плавающей точкой из потока.
     *
     * @param is Поток ввода.
     * @return Возвращает true, если чтение прошло успешно, иначе false.
     */
    bool read(istream& is) override {
        string input;
        while (true) {
            cout << "Введите число с плавающей точкой (или Ctrl+D для выхода): ";
            if (!getline(is, input) || input.empty()) return false;

            try {
                value = stod(input);
                return true;
            } catch (...) {
                cerr << "Неверный формат. Попробуйте снова." << endl;
            }
        }
    }

    /*
     * Перегрузка оператора вывода для DoubleReader.
     *
     * @param os Поток вывода.
     * @param reader Объект DoubleReader.
     * @return Возвращает поток вывода.
     */
    friend ostream& operator<<(ostream& os, const DoubleReader& reader) {
        os << "DoubleReader {value: " << reader.value << "}";
        return os;
    }
};

/*
 * Считыватель для булевых значений.
 */
class BoolReader : public InputReader {
private:
    bool value;  // Значение, считанное из ввода.

public:
    /*
     * Читает булево значение из потока.
     *
     * @param is Поток ввода.
     * @return Возвращает true, если чтение прошло успешно, иначе false.
     */
    bool read(istream& is) override {
        string input;
        while (true) {
            cout << "Введите true/false (или Ctrl+D для выхода): ";
            if (!getline(is, input) || input.empty()) return false;

            if (input == "true") {
                value = true;
                return true;
            } else if (input == "false") {
                value = false;
                return true;
            } else {
                cerr << "Неверный формат. Попробуйте снова." << endl;
            }
        }
    }

    /*
     * Перегрузка оператора вывода для BoolReader.
     *
     * @param os Поток вывода.
     * @param reader Объект BoolReader.
     * @return Возвращает поток вывода.
     */
    friend ostream& operator<<(ostream& os, const BoolReader& reader) {
        os << "BoolReader {value: " << boolalpha << reader.value << "}";
        return os;
    }
};

/*
 * Считыватель для символов.
 */
class CharReader : public InputReader {
private:
    char value;

public:
    bool read(istream& is) override {
        string input;
        while (true) {
            cout << "Введите символ (или Ctrl+D для выхода): ";
            if (!getline(is, input) || input.empty() || input.length() != 1) {
                return false;
            }
            value = input[0];
            return true;
        }
    }

    friend ostream& operator<<(ostream& os, const CharReader& reader) {
        os << "CharReader {value: " << reader.value << "}";
        return os;
    }
};

/*
 * Считыватель для строк.
 */
class StringReader : public InputReader {
private:
    string value;

public:
    bool read(istream& is) override {
        cout << "Введите строку (или Ctrl+D для выхода): ";
        if (getline(is, value) && !value.empty()) {
            return true;
        }
        return false;
    }

    friend ostream& operator<<(ostream& os, const StringReader& reader) {
        os << "StringReader {value: " << reader.value << "}";
        return os;
    }
};


/*
 * Валидатор для максимальной длины строки.
 */
class MaxLengthValidator : public Validator {
private:
    size_t maxLength;      // специальный беззнаковый целочисленный тип, определённый в стандартных библиотеках языков С и С++.

public:
    MaxLengthValidator(size_t maxLength) : maxLength(maxLength) {}

    bool validate(const string& value) override {
        return value.length() <= maxLength;
    }
};

/*
 * Валидатор для проверки диапазона.
 */
class RangeValidator : public Validator {   // попадает ли значение в заданный диапазон (мин. и макс. значение).
private:
    int min;  // Минимальное значение.
    int max;  // Максимальное значение.

public:
    /*
     * Конструктор для RangeValidator.
     *
     * @param min Минимальное значение.
     * @param max Максимальное значение.
     */
    RangeValidator(int min, int max) : min(min), max(max) {}

    /*
     * Проверяет, попадает ли значение в заданный диапазон.
     *
     * @param value Проверяемое значение.
     * @return Возвращает true, если значение валидно, иначе false.
     */
    bool validate(const string& value) override {
        try {
            int intValue = stoi(value);
            return intValue >= min && intValue <= max;
        } catch (...) {
            return false;
        }
    }
};

/*
 * Конвейер для считывания данных.
 */
class DataPipeline {
private:
    vector<InputReader*> readers;
    vector<Validator*> validators;

public:
    void addReader(InputReader* reader) {
        readers.push_back(reader);
    }

    void addValidator(Validator* validator) {
        validators.push_back(validator);
    }

    void run(std::istream& is) {
    for (size_t i = 0; i < readers.size(); ++i) {
        if (readers[i]->read(is)) {
            // Используем dynamic_cast для проверки типа
            if (auto intReader = dynamic_cast<IntReader*>(readers[i])) {
                std::cout << *intReader << std::endl;
            } else if (auto doubleReader = dynamic_cast<DoubleReader*>(readers[i])) {
                std::cout << *doubleReader << std::endl;
            } else if (auto stringReader = dynamic_cast<StringReader*>(readers[i])) {
                std::cout << *stringReader << std::endl;
            } else if (auto charReader = dynamic_cast<CharReader*>(readers[i])) {
                std::cout << *charReader << std::endl;
            }

            if (i < validators.size()) {
                std::string inputValue;
                std::cout << "Введите значение для проверки: ";
                std::getline(is, inputValue);
                if (!validators[i]->validate(inputValue)) {
                    std::cerr << "Значение не соответствует требованиям!" << std::endl;
                }
            }
        }
        delete readers[i];
    }
}

};

/*
 * Главная функция программы.
 */
int main() {
    DataPipeline pipeline;

    // Добавление считывателей
    pipeline.addReader(new StringReader());
    pipeline.addReader(new IntReader());
    pipeline.addReader(new DoubleReader());
    pipeline.addReader(new CharReader());

    // Добавление валидаторов
    pipeline.addValidator(new MaxLengthValidator(10));  // Для строки
    pipeline.addValidator(new RangeValidator(1, 100));   // Для целого числа
    pipeline.addValidator(new RangeValidator(0, 1000));  // Для числа с плавающей точкой

    pipeline.run(cin);

    return 0;
}

/*
 * Главная функция программы.
 */
/*int main() {
    InputReader* intReader = new IntReader();
    if (intReader->read(cin)) {
        cout << *dynamic_cast<IntReader*>(intReader) << endl;
    }
    delete intReader;

    InputReader* doubleReader = new DoubleReader();
    if (doubleReader->read(cin)) {
        cout << *dynamic_cast<DoubleReader*>(doubleReader) << endl;
    }
    delete doubleReader;

    InputReader* boolReader = new BoolReader();
    if (boolReader->read(cin)) {
        cout << *dynamic_cast<BoolReader*>(boolReader) << endl;
    }
    delete boolReader;

    return 0;
}*/

